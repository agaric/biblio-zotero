<?php

/**
* Implementation of hook_node_info().
*/
function biblio_zotero_node_info() {
   $items = array(
      'zotero_feed' => array(
         'name' => t('Zotero feed'),
         'module' => 'node',
         'description' => t('Subscribe to a zotero user or group. Creates nodes of the content type "biblio" from feed content'),
         'has_title' => '1',
         'title_label' => t('Title'),
         'has_body' => '1',
         'body_label' => t('Body'),
         'min_word_count' => '0',
         'help' => '',
         ),
      );
   return $items;
}

/**
* Implementation of hook_ctools_plugin_api().
*/
function biblio_zotero_ctools_plugin_api() {
   list($module, $api) = func_get_args();
   if ($module == "feeds" && $api == "feeds_importer_default") {
      // The current API version is 1.
      return array("version" => 1);
   }
}

/**
* Implementation of hook_views_api().
* This is required for your module to have its include files loaded; for example, when implementing hook_views_default_views().
*/
function biblio_zotero_views_api() {
   list($module, $api) = func_get_args();
   if ($module == "views" && $api == "views_default") {
      return array("version" => 3.0);
   }
}

/**
* Implementation of hook_feeds_plugins().
*/
function biblio_zotero_feeds_plugins() {
   $info = array();
   $info['FeedsZoteroParser'] = array(
      'name' => 'Zotero Parser',
      'description' => 'Parses json data from zotero.',
      'handler' => array(
         'parent' => 'FeedsSyndicationParser', // A plugin needs to derive either directly or indirectly from FeedsFetcher, FeedsParser or FeedsProcessor.
         'class' => 'FeedsZoteroParser',
         'file' => 'FeedsZoteroParser.inc',
         'path' => drupal_get_path('module', 'biblio_zotero'),
         ),
      );
   $info['FeedsZoteroProcessor'] = array(
      'name' => 'Zotero Processor',
      'description' => 'Routes known mapped fields to known Biblio fields and leaves the rest to be configured in the feeds UI.',
      'handler' => array(
         'parent' => 'FeedsNodeProcessor', // A plugin needs to derive either directly or indirectly from FeedsFetcher, FeedsParser or FeedsProcessor.
         'class' => 'FeedsZoteroProcessor',
         'file' => 'FeedsZoteroProcessor.inc',
         'path' => drupal_get_path('module', 'biblio_zotero'),
         ),
      );
   $info['FeedsZoteroFetcher'] = array(
      'name' => 'Zotero Http Fetcher',
      'description' => 'Fetches user and group libraries from Zotero.org',
      'handler' => array(
         'parent' => 'FeedsHTTPFetcher', // A plugin needs to derive either directly or indirectly from FeedsFetcher, FeedsParser or FeedsProcessor.
         'class' => 'FeedsZoteroFetcher',
         'file' => 'FeedsZoteroFetcher.inc',
         'path' => drupal_get_path('module', 'biblio_zotero'),
         ),
      );
   return $info; 
}

/**
* Default definition of 'biblio_zotero_importer'
*/ 
function biblio_zotero_feeds_importer_default() {
   $export = array();
   $feeds_importer = new stdClass;
   $feeds_importer->disabled = FALSE; /* Edit this to true to make a default feeds_importer disabled initially */
   $feeds_importer->api_version = 1;
   $feeds_importer->id = 'zotero_feed';
   $feeds_importer->config = array(
      'name' => 'Zotero Feed',
      'description' => 'Import Zotero items.',
      'fetcher' => array(
         'plugin_key' => 'FeedsZoteroFetcher',
         'config' => array(
            'auto_detect_feeds' => FALSE,
            'use_pubsubhubbub' => FALSE,
            'designated_hub' => '',
            ),
         ),
      'parser' => array(
         'plugin_key' => 'FeedsZoteroParser',
         'config' => array(),
         ),
      'processor' => array(
         'plugin_key' => 'FeedsZoteroProcessor',
         'config' => array(
            'content_type' => 'biblio',
            'update_existing' => 0,
            'expire' => '-1',
            'mappings' => biblio_zotero_get_default_mappings(),
            'input_format' => 0,
            'author' => 0,
            'sync_tags' => FALSE,
            'tags_vocab_id' => NULL,
            ),
         ),
      'content_type' => 'zotero_feed',
      'update' => 0,
      'import_period' => '1800',
      'expire_period' => 3600,
      'import_on_create' => 1,
      );
   
   $export['biblio_zotero_importer'] = $feeds_importer; 
   return $export;
}

function biblio_zotero_node_presave($node) {
   // dpm($node, "node@hook_node_presave");
   // dpm(debug_backtrace(), "debug backtrace");
}

/**
* http://drupalcontrib.org/api/drupal/contributions%21feeds%21feeds.api.php/function/hook_feeds_processor_targets_alter/7
**/
function biblio_zotero_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
}

/**
* http://drupalcontrib.org/api/drupal/contributions%21feeds%21feeds.api.php/function/hook_feeds_parser_sources_alter/7
**/
function biblio_zotero_feeds_parser_sources_alter(&$sources, $content_type) {
}

function biblio_zotero_get_default_mappings() {
   module_load_include('inc', 'biblio_zotero', 'zotero');
   $all_mappings = array();
   $itemTypesStructure = array_keys(Zotero::getItemTypeStructure());
   foreach ($itemTypesStructure as $itemType) {
      if ( in_array($itemType, array('note', 'attachment')) ) {
         continue;
      }
      $filename  = "mappings/" . $itemType . ".mapping";
      module_load_include('inc', 'biblio_zotero', $filename);
      $function_name = "biblio_zotero_get_field_mappings__$itemType";
      $item_type_mappings = call_user_func($function_name);
      biblio_zotero_remove_empty_targets($item_type_mappings);
      $all_mappings = array_merge($all_mappings, $item_type_mappings);      
   }
   $other_mappings = array( 
      array(
         'source' => 'guid',
         'target' => 'guid',
         'unique' => TRUE,
         ),
      array(
         'source' => 'title',
         'target' => 'title',
         'unique' => FALSE,
         ),
      array(
         'source' => 'timestamp',
         'target' => 'created',
         'unique' => FALSE,
         ),
      array(
         'source' => 'note',
         'target' => 'biblio_notes',
         'unique' => FALSE,
         ),
      /** @TODO  UNCOMMENT WHEN notes are properly mapped
      array(
         'source' => 'notes',
         'target' => 'biblio_notes',
         'unique' => FALSE,
         ), */
      );
   $all_mappings = array_merge($other_mappings, $all_mappings);      
   return $all_mappings;
}

function biblio_zotero_remove_empty_targets(&$mappings) {
   foreach ($mappings as $idx => $mapping) {
      if ( empty( $mapping['target']) ) {
         unset($mappings[$idx]); 
      }
   }
}



